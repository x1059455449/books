# 第一章

## 作用域嵌套

**当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。**

**遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。**

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

> 例子

```
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );

找出所有的 LHS 查询（这里有 3 处！）
c = ..;、a = 2（隐式变量分配）、b = ..

找出所有的 RHS 查询（这里有 4 处！）
foo(2..、= a;、a ..、.. b
```

# 第二章 词法作用域

## 欺骗词法

> evel(建议弃用)

JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

**详情参考MDN：**[MDN evel](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)

>> 例子

```
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
eval(..) 调用中的 "var b = 3;" 这段代码本身会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实上，这段代码实际在 foo(..) 内部已经创建了一个变量 b，并遮蔽了外部（全局）作用域中的同名变量。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。

对比MDN上面的例子，我们可以得出一个结论，无论在何种情况下，eval(..) 都可以在运行期修改书写期的词法作用域。若是在工作中不停地使用evel()函数来进行嵌套，那就会掉入我们常说的evel回调地狱。

想了解更多关于回调地狱的信息，请自行在各大搜索平台搜索“**回调地狱**”

若在严格模式下，并不会发生类似回调地狱的问题，比如上面的例子：

```
function foo(str, a) {
    "use strict";
    eval( str );
    console.log( a, b ); // ReferenceError: a is not defined
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

类似的函数还有setTimeout() 和 setInterval()等

> with(建议弃用)

[MDN with](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with)

# 第三章 函数作用域和块作用域




